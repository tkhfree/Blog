---

title: Shell使用介绍
date: 2022-11-27 12:07
tags:
  -  shell
  -  linux

categories:
  - 技术：知识技能

comments: true
toc: true

---
shell脚本的一些方法，想到什么命令就记什么命令了。
[toc]
### set

```shell
set -u -x -e -o pipefail
开局使用
-u是使用未定义的变量时报错并终止。
-x是先打印脚本里执行的命令再执行
-e只要遇到错误就终止执行 +e关闭这个功能
-o pipefail是针对管线的，因为对于管线命令来说，只要管线最后输出exit 0/执行正确，则-e -u等就不会终止执行，使用这个可以对管线每个命令进行判断
```

还有另一种针对单个命令执行判断的方法

```shell
command || exit 1
```

### sed

sed 简单用法 - 低调行事的文章 - 知乎 https://zhuanlan.zhihu.com/p/109773710sed 简单用法 - 低调行事的文章 - 知乎 https://zhuanlan.zhihu.com/p/109773710

### ||与&& 

|| 与 &&的区别

```shell
command1 || command2
执行完command1不成功才执行command2

command1 && command2 
执行完command1成功之后执行command2
```

```shel
` `之内的内容是需要执行的命令，取执行命令的结果
```

```shell
grep -c ^head <file>
输出file文件head开头的字符串个数
```

### 运算符

```shell
取变量名用$,像c语言的指针概念。
$0 脚本本身的名称
$1 脚本后跟的第一个参数
$# 参数个数
$？最后命令的退出状态
$* 所有参数
$$ 脚本当成进程id号
$@ 与$*作用一样
```

```shel
expr是一款表达式计算器，可以计算数值运算的值
`expr 1 + 1 `
或者
$[ 1+1 ]
```

```shell
关系运算符（只适用于数字）
-eq 检查是否相等，相等返回true    : equals
-ne 检查是否相等，不相等返回true  : not equals
-gt 左边大于右边，返回true       : greater than
-lt 右边大于左边，返回true       : less than
-ge 左边大于等于右边，返回true    : greater equals
-le 左边小于等于右边，返回true    : less equals


! 非运算
-o 或运算
-a 与运算

-e 文件或者目录是否存在  ： -e $file
```

### 脚本输出EOF用法

EOF通常都配合<<使用，unix环境下<<之后的字符是一个标志符，标识符之间的内容被输入，所以标识符可以是任何内容，只是通常用EOF（End Of File）代替。

```shell
<< EOF
...
EOF
```

...内容都被输入进去。

输入到哪用cat >>来指定文件

< :输入重定向
\> :输出重定向
\>> :输出重定向,进行追加,不会覆盖之前内容
<< :标准输入来自命令行的一对分隔号的中间内容.

```shell
xxxxxxxxxx tangkaifeideMacBook-Pro:Documents tang$ cat <<EOF >>test.sh "this is a cat&EOF demo" EOF
```

### echo用法

结果定向至文件

```shell
echo "It is a test" > myfile
```

显示命令结果用   **\`   \` ** 表示或者$()

```shell
echo `ls`
echo $(ls)
```

### 输入重定向

标准输入	命令<文件1	命令把文件1的内容作为标准输入设备
标识符限定输入	命令<<标识符	命令把标准输入中读入内容，直到遇到“标识符”分解符为止
输入输出重定向（同时使用）	命令< 文件1 >文件2	命令把文件1的内容作为标准输入，把文件2作为标准输出。

还有一个进程替换<()

```shell
$ cat <(ls)    #把<(ls)当一个临时文件，文件内容是ls的结果，cat这个临时文件
```

### 输出重定向

- 0: 代表标准输入
- 1: 代表标准输出
- 2:代表标准错误输出

正常输入输出都会在控制台显示，例如：

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls
tang_hexo_blog	test.sh
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errofile
ls: errofile: No such file or directory
-rw-r--r--  1 tang  staff  40  5 22 17:23 test.sh
tangkaifeideMacBook-Pro:Documents tang$ 
```

我们可以把正常输出定向到文件夹内：

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errofile >test.sh 
ls: errofile: No such file or directory
tangkaifeideMacBook-Pro:Documents tang$ cat test.sh 
-rw-r--r--  1 tang  staff  0  5 22 17:36 test.sh
```

或者一样效果的：

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errofile 1>test.sh 
ls: errofile: No such file or directory
tangkaifeideMacBook-Pro:Documents tang$ cat test.sh 
-rw-r--r--  1 tang  staff  0  5 22 17:36 test.sh
tangkaifeideMacBook-Pro:Documents tang$ 
```

与此对应，可以把错误输出定向到文件夹内:

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errofile 2>test.sh 
-rw-r--r--  1 tang  staff  0  5 22 17:37 test.sh
tangkaifeideMacBook-Pro:Documents tang$ cat test.sh 
ls: errofile: No such file or directory
tangkaifeideMacBook-Pro:Documents tang$ 
```

如果同时重定向错误信息和重定向标准输出到文件必须使用两个重定向符号，并且必须在重定向符前加上相应的文件描述符:

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errorfile 1>testright.txt 2>testerror.txt 
tangkaifeideMacBook-Pro:Documents tang$ cat testright.txt 
-rw-r--r--  1 tang  staff  40  5 22 17:37 test.sh
tangkaifeideMacBook-Pro:Documents tang$ cat testerror.txt 
ls: errorfile: No such file or directory
tangkaifeideMacBook-Pro:Documents tang$ 
```

如果想将标准输出和错误信息重定向到一个日志文件，Bash Shell提供了&符，就不需要使用两个重定向符了:

```shell
tangkaifeideMacBook-Pro:Documents tang$ ls -l test.sh errorfile >test.sh 2>&1
tangkaifeideMacBook-Pro:Documents tang$ cat test.sh 
ls: errorfile: No such file or directory
-rw-r--r--  1 tang  staff  0  5 22 17:43 test.sh
tangkaifeideMacBook-Pro:Documents tang$ 
```

### 重定向到垃圾桶

```shell
command >/dev/null 2>&1 #0标准输入 1标准输出 2错误输出
```

### 输出变量

```( set -o posix ; set ) | less```

### 查看进程

```shell
ps -ef|grep syslog|grep -v "grep"

pstree -p PID #查看进程树
top -H -p PID #查看cpu利用率
```
### inode

硬链接`ln`和软链接`ln -s`的区别，硬链接时两个文件有相同的inode号，软链接时创建一个文件，这个文件的内容是打开另一个文件的inode，所以两个文件虽然最终都是打开一个inode，但是创建两个inode。

[Linux的inode的理解](https://blog.csdn.net/xuz0917/article/details/79473562)

```shell
利用${ } 还可针对不同的变数状态赋值(沒设定、空值、非空值)： 
${file-my.file.txt} ：假如$file 沒有设定，則使用my.file.txt 作传回值。(空值及非空值時不作处理) 
${file:-my.file.txt} ：假如$file 沒有設定或為空值，則使用my.file.txt 作傳回值。(非空值時不作处理)
${file+my.file.txt} ：假如$file 設為空值或非空值，均使用my.file.txt 作傳回值。(沒設定時不作处理)
${file:+my.file.txt} ：若$file 為非空值，則使用my.file.txt 作傳回值。(沒設定及空值時不作处理)
${file=my.file.txt} ：若$file 沒設定，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(空值及非空值時不作处理)
${file:=my.file.txt} ：若$file 沒設定或為空值，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(非空值時不作处理)
${file?my.file.txt} ：若$file 沒設定，則將my.file.txt 輸出至STDERR。(空值及非空值時不作处理)

${file:?my.file.txt} ：若$file 没设定或为空值，则将my.file.txt 输出至STDERR。(非空值時不作处理)

${#var} 可计算出变量值的长度：

${#file} 可得到27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节
```

[一篇教会你写90%的shell脚本-zhihu](https://zhuanlan.zhihu.com/p/264346586)

---
在${ }内可以实现字符串的替换、删除、截取

- 截取

可以有从指定位置计数
```
${cfg:2:5} //字符串：开始位置：截取的长度 
${cfg:2} //截取从第2个字符开始直到字符串结尾
```
及从指定的子字符串计数
```
${cfg#*substring} //*substring就是子字符串，cfg是字符串，从substring匹配到的左侧全都不要；##代表最后一个匹配到的子字符串
${cfg%substring*}  //同理，从substring开始的之后所有字符串就不要了，*代表的是通用匹配符，注意左侧右侧截取分别是#和%；%%代表最后一个匹配到的子字符串
```
- 替换
```
${cfg/原来字符/新的字符}
例如${cfg/aa/bb} //将aa替换成bb
${cfg/\//\#}    //将/替换成#
${cfg//aa/bb}   //将所有aa替换成bb	
```
### export和source
export定义了之后变量变为系统变量，可以再本进程和子进程中调用，但是在脚本中定义了之后，在登录的shell进程中不能调用，因为登录的shell进程是该脚本的父进程
source可以免除注销再登录的变量定义，例如在脚本中定义了变量，source该脚本，则在登录的shell进程中可以调用，相当于没有再执行子进程

**总结：export定义的变量可以在本进程和子进程中使用，不能在父进程中调用；source脚本是把脚本在登录shell中执行，没有开子进程**

**linux的网络配置主要在/etc里**

/etc/sysconfig/network-scrips/ifcfg-en0
设定网卡的参数，例如ip、子网掩码、路由器、IP获取方式等

/etc/hosts
设定主机别名和ip的对应

/etc/services
设置Linux里服务进程的端口

/etc/resolve.conf
设置dns的地址


### Linux的网络指令
ifconfig 查看网卡信息

route 查看路由表

ping 测试通不通

traceroute 查看路由转发的节点

netstat 查看网络服务的端口启动情况 netstat -tulnp

host 查看域名对应的ip，调用/etc/resolv.conf的dns服务器查询

telnet ftp ssh wget

### tcpdump 封包分析指令
[root@linux ~]# tcpdump [-nn] [-i 介面] [-w 储存档名] [-c 次数] [-Ae]
                        [-qX] [-r 档案] [所欲撷取的资料内容]
参数：
-nn：直接以 IP 及 port number 显示，而非主机名与服务名称
-i ：后面接要‘监听’的网路介面，例如 eth0, lo, ppp0 等等的介面；
-w ：如果你要将监听所得的封包资料储存下来，用这个参数就对了！后面接档名
-c ：监听的封包数，如果没有这个参数， tcpdump 会持续不断的监听，
     直到使用者输入 [ctrl]-c 为止。
-A ：封包的内容以 ASCII 显示，通常用来捉取 WWW 的网页封包资料。
-e ：使用资料连接层 (OSI 第二层) 的 MAC 封包资料来显示；
-q ：仅列出较为简短的封包资讯，每一行的内容比较精简
-X ：可以列出十六进位 (hex) 以及 ASCII 的封包内容，对于监听封包内容很有用
-r ：从后面接的档案将封包资料读出来。那个‘档案’是已经存在的档案，
     并且这个‘档案’是由 -w 所制作出来的。
所欲撷取的资料内容：我们可以专门针对某些通讯协定或者是 IP 来源进行封包撷取，
     那就可以简化输出的结果，并取得最有用的资讯。常见的表示方法有：
     'host foo', 'host 127.0.0.1' ：针对单部主机来进行封包撷取
     'net 192.168' ：针对某个网域来进行封包的撷取；
     'src host 127.0.0.1' 'dst net 192.168'：同时加上来源(src)或目标(dst)限制
     'tcp port 21'：还可以针对通讯协定侦测，如 tcp, udp, arp, ether 等
     还可以利用 and 与 or 来进行封包资料的整合显示呢！



nc 或者 netcat 
nc -l -p 20000 启用tcp协议的20000端口listen
nc localhost 20000 连接20000端口
可以在两个bash中进行同步通信

### 目录操作
**创建目录**

```
mkdir
```
**切换目录**

```
cd ..
cd
```
**移动目录**

```
mv /home/test /var/tmp
```
**删除目录**

```
rm -rf var/test
```
**查看目录**

```
ls
```
##文件操作

**创建文件**

```
touch ~/testfile
```
**删除文件**

```
rm ~/testfile
```
**复制文件**

```
cp ~/testfile ~/testnewfile
```
**查看文件内容**

```
cat ~/.bash_history
```
##过滤、管道与重定向
**过滤文件内内容**

```
grep 'root' /etc/pwd
```
**过滤文件夹内内容**

```
grep -r 'linux' /var/log
```
**管道**
管道的作用是将上一个命令的输出和下一个命令的输入连接起来

```
cat ~/.bash_history | grep 'ls' 
```
**重定向**
使用>或者<将内容重定向文件中 

```shell
 echo 'hello,world!'> ~/test.txt
```

### 运维常用命令

**ping**
四个ping包

```
ping -c 4 www.baidu.com
```
**网络状态**

```
netstat -lt
netstat -tulpn
```
**过滤得到当前系统ssh信息**

```
ps -aux | grep 'ssh'
```

```

----------

anaconda切换环境
conda info -e
activate python2

----------

```

### Linux离线安装apt包

首先需要了解的是在网络正常情况下使用apt -d install 安装，会把包下载在*/var/cache/apt/archives/*下。

因此整体思路就是在正常的安装，把下载的包和依赖包拷贝到离线机器上，构建包索引，执行安装

如果正常机器上已经安装需要的包了，那么使用aptitude工具卸载安装的包

（0）aptitude可以卸载包及依赖的包

`sudo aptitude remove`

（1）清理apt的下载缓存区。

```html
sudo rm -rf /var/cache/apt/archives/*
```

（2）下载所需要的组件

```html
sudo apt-get -d install <包名>
```

（3）创建一个目录，将下载的包拷贝到该目录下

```html
cp -r /var/cache/apt/archives  /yout-path
```

（4）修改目录权限

```html
 chmod 777 -R /your-path
```

（5） 建立deb包的依赖关系

```html
sudo touch /your-path/Packages.gz



sudo dpkg-scanpackages /your-path/ /dev/null  | gzip > /your-path/Packages.gz
```

（6）将所有下载的文件和生成的gz文件拷贝到离线的ubuntu机器上，将 /etc/apt/sources.list原有内容注释掉，新增：

```html
deb file:/var debs/
```

（7）执行 sudo apt-get update，之后就可以直接使用apt-get install 包名 来安装了

### sudo -E

简单来说，就是加上`-E`选项后，用户可以在sudo执行时保留当前用户已存在的环境变量，不会被sudo重置，另外，如果用户对于指定的环境变量没有权限，则会报错。

### 文件大小

`df -h`查看系统中文件的使用情况

`du -sh *`查看当前目录下各个文件及目录占用空间大小

可以排序查看 `du -sh \root\* | sort -nr`
