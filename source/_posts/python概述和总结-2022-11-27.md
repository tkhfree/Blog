---

title: python概述和总结
date: 2022-11-27 12:46
tags:
  -  python

categories:
  - 方法：方法论（经验谈）

comments: true
toc: true

---

 - python是一个解释型，交互式，无编译的面向对象语言 python缺点：
   
    1. 运行慢，因为python是一个交互式面向对象语言，执行python语句时，每执行一句就要编译一句。c语言是编译好cpu可以执行的文件之后再运行。但是由于网络的延迟，这一缺点影响很小
    2.加密性。解释型语言只能发布源码，而编译型语言可以发布编译后的文件（xxx.exe）。
   
 - python中字符串用单引号'和双引号"都可以，但不可以混用

   


 - python是一个动态语言，变量本身类型不固定

   
   
 - str是不变对象，而list是可变对象。对于可变对象，比如list，对list进行操作，list内部的内容是会变化的。元组(tuple)、数值型（number)、字符串(string)均为不可变对象,而字典型(dictionary)和列表型(list)的对象是可变对象
## 数字类型

### 整形

int long

### 浮点型

float

### 复数

In [11]:

```
a = 1
type(a)
b=1.0
type(b)
c=1111111111111111111111111111111
type(c)
```

Out[11]:

```
int
```

## 表达式

不支持i++，使用i+=1

In [15]:

```
a=6+8
print (a)
14
```

## 字符串和列表

字符串就是特殊形式的列表，但是字符串的值是常量，对于字符串的更改都是更改的其副本，列表是变量，对于列表更改内容，列表地址不变。

字符串养成习惯用双引号来表示

python没有数组的概念，用列表表示，列表中可以存放任意类型的数据，同一列表可以放置多种数据

In [55]:

```
# 取下标操作
str_test="hello"
list_test=["h","e","l","l","o"]
print (str_test[0])
print (list_test[0])
# 取1个到第3个之间的元素
print (str_test[1:4])
print (list_test[0:4])
# 取第1个到5个之间的元素，每隔2个取1个
print (str_test[0:5:2])
print (list_test[0:5:2])
# 取某个元素的下标
print (str_test.index("e"))
print (list_test.index("o"))
# 逆序取得某个元素
print (str_test[-1])
print (list_test[-1])
# 追加元素
print (str_test+",world")
print (list_test+[",","world"])
# 计算长度
print (len(str_test))
print (len(list_test))
# 多次复制
print(str_test*3)
print(list_test*4)
# 复制新变量
str_new_test = str_test[:]
list_new_test = list_test[:]
print(str_new_test)
print(list_new_test)
# python中变量名有点像c中的指针
str_new_test1 = str_new_test
print(id(str_new_test))
print(id(str_new_test1))
print(id(str_test))

# 列表变量可以更改元素
list_test[1]="i"
print(list_test)
# 列表追加
list_test.append("world")
print(list_test)

print(list_test+["python"])
# 列表在第1位插入
list_test[1:1]=[1234567]
print(list_test)

# 字符串的大小写转变
str_test_upper = str_test.upper()
print(str_test_upper)
h
h
ell
['h', 'e', 'l', 'l']
hlo
['h', 'l', 'o']
1
4
o
o
hello,world
['h', 'e', 'l', 'l', 'o', ',', 'world']
5
5
hellohellohello
['h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o', 'h', 'e', 'l', 'l', 'o']
hello
['h', 'e', 'l', 'l', 'o']
140384645081328
140384645081328
140384645081328
['h', 'i', 'l', 'l', 'o']
['h', 'i', 'l', 'l', 'o', 'world']
['h', 'i', 'l', 'l', 'o', 'world', 'python']
['h', 1234567, 'i', 'l', 'l', 'o', 'world']
HELLO
```

## 列表

In [*]:

```
# 几种构建列表方式
list_test1=list("helloworld")
list_test2=["h","e","l","l","o"]
list_test3=[x for x in range(10)]
list_test4=map(lambda x:x ,[1,2,3,4,5])
print(list_test4)
print(list_test1)
```

## **lambda**

构造匿名函数

result = lambda x : x+1

等同于

def result(x): return x+1

## map

map(function,sequenec[,sequence, ...]) -->list

map接受两个参数，一个函数，一个可迭代的对象或者是序列，返回一个列表

## 元组

元组就是常量化的列表

tuple_test=(1,2,3,4,5)

元组表达跟列表基本一致，只是元组里的元素不能修改，列表的操作（除了修改）元组也都可以操作

列表转为元组

tup_test=tuple([1,2,3,4,5])

**什么时候用元组？当希望把一个序列作为参数传递时，不希望被修改**

## 字典

与java中map对应，字典也是一个键值对结构

dict_test={"aa": 1, "bb": 2 , 1:aa , 1.3:bb}

取值

dict_test["aa"] dict_test[2]

dict_test[1.3]

新添加键值对

dict_test["test"]="helloworld"

更新键值对

dict_test["aa"]="python"

## 集合

集合和列表相似，但是集合不能存放相同的元素

set_test=set([[1,2,3,4,5,1,2,3,4,5]])    -->[1,2,3,4,5]

## 异常处理

异常处理基本同java 类似，在try点创建一个标记，当遇到异常时匹配except，抛出异常，如果没有匹配的异常，则向上传递。

```python
try:
  exec1
  try:
    exec2
  fianlly:
    exec3
except ErrorType:
  catch error
```

## 函数

```pyhton
def func(name, age, cls="", *arg, **karg):
```

函数用def定义，func是函数名，name，age是普通参数，必须按位置传入，cls是关键字参数或者默认参数，缺省可选，karg也是关键字参数，和cls关键字参数不一样的是，在函数中存在，但是不知道具体名称的关键字参数，arg是位置参数，同样是在函数中存在，但是不知道具体名称的位置参数。

参数的位置一定是按照（位置参数，关键字参数，*参数，**参数）的顺序来写，其中位置参数如果设定就一定要传入，如果参数定义为：

```python
def func(*arg, **karg):
  state
```

则表示函数可以传入任意类型和任意数量的参数

传参形式是有多种多样的。

```python
def func(name, age=10):
  print ("name is %s, age is %d" %(name,age))
#调用方式
func("hello")
func("hello", 20)
func(name="hello", age=20)
func(age=20, name="hello")

param_list=["hello",20]
func(*param_list)

param_dict={"name":"hello", "age":20}
func(**param_dict)
```

## 迭代器

迭代器iterator需要实现两个方法：

1. \__iter__，返回迭代器自身
2. \__next__，返回迭代器下一个元素

```python
class myiter(object):
    def __init__(self, count):
        self.count = count
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if (0 >= count):
            raise StopIteration()
        else:
            self.count -= 1
            return self.count

myiter it = myiter(4)
while 1:
    e = it.__next__()
    print e
```

## 生成器

迭代器+协程

用open函数打开文件时，最好使用生成器模式。

创建生成器的方式

```python
# 使用yield函数,每次执行都生成一个hello，获取它的值需要配合使用next函数或者迭代获取
def first_generator():
    yield "hello"

result = first_generator()
result.next()
# 使用()获得生成器,当（）配合def使用是方法或者函数，当（）配合“,”使用是构造元组tumple，当和列表推导一起使用是生成器
second_generator = (x for x in range(10))
```

def定义的时一个普通函数，但是里面出现yield这个关键词，这就不是普通函数了，变成生成器了，有next这个成员函数（python3里变成\__next__），**生成器=迭代器+协程**

yield两重魔力，第一重是迭代器有\_\_next\_\_函数，第二重当执行到yield时，相当于return object，但是没有并不完全一样，因为return会退出函数，而yield不会，相当于保存了运行的上下文，把函数挂起来。既然把函数挂起来，相当于该协程让出程序执行权，当\__next\_\_再次被调用，就从当前被挂起的上下文继续执行，这样可以一直循环下去，直到执行不到yield会抛出Raise StopIteration异常。

可以使用生成器实现cat file | grep keyword这样的Linux命令

```python
#!/usr/bin/python

with open("filepath","r+") as file_obj:
  	for file in file_obj:
      	if “keyword” in file.strip():
          	print file
        else:
          	pass
```

[迭代器和生成器的大白话解释](https://segmentfault.com/a/1190000007208388)

## argv和raw_input

argv和raw_input都可以从命令行输入参数，不同点在于argv是从开始运行py文件时，就将输入以参数的形式在程序里使用；raw_input是在程序执行时，根据提示输入数据。

## \_\_name\_\_ ==\_\_main\_\_

\_\_name\_\_是内置变量，表示的是当前模块的名字。当前python文件是程序的主入口时，当前模块的\_\_name\_\_就是\_\_main\_\_，如果当前python文件不是程序的主入口，python是以模块import进来的，则\_\_name\_\_表示当前包的层次，是导入的文件名。

python的\-m参数用于将一个模块或者包作为一个脚本运行，而\_\_main\_\_.py文件相当于是一个包的入口程序。

`python xxx.py` 与 `python -m xxx.py` 的区别，一种是直接运行，一种是当做模块来运行。

```python
#!/user/bin/python
#coding=utf-8
#run.py
import sys
print __name__
print sys.path
```

两种运行方式

```shell
python run.py
__main__    #__name__的值
['/yh1', '/usr/lib/python27.zip',...]


python -m run.py
run   #__name__的值
['', '/usr/lib/python27.zip', ...]
/usr/bin/python: No module named run.py
```

## python的简洁if语句

1. 普通写法

```python
a, b, c = 1, 2, 3
if a > b :
    c =a 
else:
    c = b 
```

2. 一行表达式，为真时放if前，也就是if前的表达式是if为true的值

```python
c = a if a > b else b;
```

3. 二维列表，利用大小判断的0，1当索引

```python
c = [b, a][a>b]
```


## list&tuple
list是一个可变数组，tuple是一个不可变数组。（指向永不变），tuple("a","b",["x","y"])，x，y可变，a，b不可变。
## dict&set
python字典是dict函数，其他语言也有称为map，使用键-值（key-value）存储。set跟dict类似，是一组不能改变的key集合，要创建一个set，需要提供一个list作为输入集合
## range
python range()函数生成整数序列，list函数生成list，例如list(range(5))
###函数

 - 定义函数时，需要确定函数名和参数个数；
   
 - 如果有必要，可以先对参数的数据类型做检查；

   


 - 函数体内部可以用return随时返回函数结果；

   


 - 函数执行完毕也没有return语句时，自动return None。

  

 - 函数可以同时返回多个值，但其实就是一个tuple。
 - 函数可以传递默认参数，放在可变参数后面，默认参数必须指向不变对象，不然每次调用一次默认参数的函数就会在指向对象上发生改变
 - 函数可以定义可变参数，定义可变参数传入需是list或者tuple。或者定义函数时可变参数加上*。这样调用时可以输入任意数量参数，或者加上*的list/tuple
 - 关键字参数。可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

    def person(name, age, **kw):
        print('name:', name, 'age:', age, 'other:', kw)
 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数或者包含任意个数的关键字参数：

     person('Bob', 35, city='Beijing')
    name: Bob age: 35 other: {'city': 'Beijing'}

 - 返回函数中内部函数可以调用外部函数的参数和局部变量，当调用外层函数输出内部函数的时候，这个参数和局部变量都保存起来了，返回的函数其实并没有被调用，只有调用返回赋值的变量的时候才被调用

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

    def f1(a, b, c=0, *args, **kw):
        print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
    
    def f2(a, b, c=0, *, d, **kw):
        print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
## 装饰器
[详解Python的装饰器](https://www.cnblogs.com/cicaday/p/python-decorator.html)
在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator），本质上，decorator就是一个返回函数的高阶函数。
## python连接数据库
#数据库操作 
采用mysql数据库

#### 登录数据库 

```
mysql -uroot -p
```
#### 创建数据库 

```
create database name
```

#### 显示数据库 

```
show databases
```
#### 删除数据库 
```
drop database name
```
#### 进入数据库 
```
use databasename
```

## sqlalchemy
object-relation mapping（ORM）技术，把关系数据库的表结构映射到对象上

安装mysql数据库、mysql-python驱动、sqlalchemy包

----------
- 自增长
auto_increment
- 类型
Type
- 非空
not null
- 默认值
default 'xx'
- 唯一
unique
- 指定字符集
charset
- 键
primary key
- 外键
增加两个表之间的联系

----------


#### 导入sqlalchemy包

```
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, Integer
from sqlalchemy.orm import sessionmaker
```
#### 与数据库连接

```
from sqlalchemy import create_engine
engine = create_engine('mysql+mysqldb://root:1221@localhost:3306/pytest')
```
数据库类型+驱动：//数据库账号：密码@ip：端口/数据库名字
#### 创建基类 

```
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
```
#### 描述表结构
创建一个类User1，继承基类
```
class User1(base):
       __tablename__:'username'

       id = Colume(Integer,primary_key = True)
       name = Colume(String(30),nullable = False,index=True)
       password = colume(Integer)

       def __repr__(self):
              return '%s(%r)' %(self.__class__.__name__,self.username)
```

__tabelename__指定表的名字，除了String、Integer类型还有Text，Boolean，DateTime等。nullable=False 代表这一列不可以为空，index=True 表示在该列创建索引。定义 __repr__ 是为了方便调试，你可以不定义，也可以定义的更详细一些
#### 创建实例（建立表）

```
Base.metadata.create_all(engine) 
```



#### 建立会话
```
om sqlalchemy.orm import sessionmaker

Session = sessionmaker(bind=engine)
session = Session()
```
可以把 sessionmaker 想象成一个手机，engine 当做 MySQL 的号码，拨通这个“号码”我们就创建了一个 Session 类，下面就可以通过这个类的实例与 MySQL 愉快的交谈了！

## 简单 CURD
#### Create


```
ssion.add_all([User1(name = 'ed',password = '1111111'),
User1(name = 'ad',password = '1111112'),
])
session.commit()

```
#### Retrieve


```
for instance in session.query(tang).order_by(tang.name):
            print(instance.name, instance.age)
for name, fullname in session.query(tang.name, tang.age):
            print(name, fullname)
print(session.query(tang).get(5)) 
for t1, in session.query(tang.name).filter(tang.age == 24):
            print t1
```
session.query(class).get(index)
或者
session.query(class.colume)
session.query(class).all()
session.query(class.colume).filter(条件)
```python
#相等
query.filter(User.name == 'ed')
#不相等
query.filter(User.name != 'ed')
#like
query.filter(User.name.like('%ed%'))
#in
query.filter(User.name.in_(['ed', 'wendy', 'jack']))
query.filter(User.name.in_(
    session.query(User.name).filter(User.name.like('%ed%'))
))
#not in
query.filter(~User.name.in_(['ed', 'wendy', 'jack']))
#IS NULL
query.filter(User.name == None)
query.filter(User.name.is_(None))
#IS NOT NUKK
query.filter(User.name != None)
query.filter(User.name.isnot(None))
#And
from sqlalchemy import and_
query.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))
query.filter(User.name == 'ed', User.fullname == 'Ed Jones')
query.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')
#OR
from sqlalchemy import or_
query.filter(or_(User.name == 'ed', User.name == 'wendy'))
#Match
query.filter(User.name.match('wendy'))
```
#### update
```
a = session.query(User1).get(1)
a.password=88888
session.add(a)
session.commit()
```
#### delete

```
 a = session.query(User1).get(1)
 session.delete(a)
 session.commit()
```
## python处理日志
##### 日志相关概念
日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表
明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性
也可以被称为严重性级别（level）。

##### 日志的作用
通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操
作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该
应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。
简单来讲就是，我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时
快速定位问题。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部
分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运
维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可
以简单总结为以下3点：
•程序调试
•了解软件程序运行情况，是否正常
•软件程序运行故障分析与问题定位
如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析，如：分析用户的操作行为、类型洗好、地域分布以及
其它更多的信息，由此可以实现改进业务、提高商业利益。

##### 日志的等级
我们先来思考下下面的两个问题：
•作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？
•作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？
在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把
该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序正式发布或在生产环境部署应
用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们
在排查故障时被淹没在日志的海洋里。那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程
度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。
不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：
• DEBUG
• INFO
•NOTICE
•WARNING
•ERROR
•CRITICAL
•ALERT
•EMERGENCY

##### 日志字段信息与日志格式
本节开始问题提到过，一条日志信息对应的是一个事件的发生，而一个事件通常需要包括以下几个内容：
•事件发生时间
•事件发生位置
•事件的严重程度–日志级别
•事件内容
上面这些都是一条日志记录中可能包含的字段信息，当然还可以包括一些其他信息，如进程ID、进程名称、线程ID、线程
名称等。日志格式就是用来定义一条日志记录中包含那些字段的，且日志格式通常都是可以自定义的。
说明：
输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可
以了。

##### 日志功能的实现
几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：log4j，log4php
等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块–logging。

#### logging模块简介
logging模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。logging模块是Python的一个标准
库模块，由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能。所以，你的应用日
志可以将你自己的日志信息与来自第三方模块的信息整合起来。

##### logging模块的日志级别

logging模块默认定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发
供别人使用的库时，因为这会导致日志级别的混乱。
日志等级（level）
描述
Alt text
开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调
试；应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取
错误日志信息的效率。日志级别的指定通常都是在应用程序的配置文件中进行指定的。
说明：
•上面列表中的日志等级是从上到下依次升高的，即：DEBUG < INFO < WARNING < ERROR < CRITICAL，而日志的
信息量是依次减少的；
•当为某个应用程序指定一个日志级别后，应用程序会记录所有日志级别大于或等于指定日志级别的日志信息，而不是仅
仅记录指定级别的日志信息，nginx、php等应用程序以及这里要提高的python的logging模块都是这样的。同样，
logging模块也可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等
级的日志记录将会被丢弃。

##### logging模块的使用方式介绍
logging模块提供了两种记录日志的方式：
•第一种方式是使用logging提供的模块级别的函数
•第二种方式是使用Logging日志系统的四大组件
其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。
logging模块定义的模块级别的常用函数
Alt text
其中logging.basicConfig(** kwargs)函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打
开模式”等信息，其他几个都是用于记录各个级别日志的函数。
logging模块的四大组件
Alt text
说明： logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些
类的实例时设置了一些默认值。

##### 使用logging提供的模块级别的函数记录日志
回顾下前面提到的几个重要信息：
•可以通过logging模块定义的模块级别的方法去完成简单的日志记录
•只有级别大于或等于日志记录器指定级别的日志记录才会被输出，小于该级别的日志记录将会被丢弃。

##### 最简单的日志输出
先来试着分别输出一条不同日志级别的日志记录：

import logging
logging.debug("This is a debug log.")

logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")
输出结果：
WARNING:root:This is a warning log.
ERROR:root:This is a error log.
CRITICAL:root:This is a critical log.

##### 那么问题来了
问题1：为什么前面两条日志没有被打印出来？
这是因为logging模块提供的日志记录函数所使用的日志器设置的日志级别是WARNING，因此只有WARNING级别的日志
记录以及大于它的ERROR和CRITICAL级别的日志记录被输出了，而小于它的DEBUG和INFO级别的日志记录被丢弃了。
问题2：打印出来的日志信息中各字段表示什么意思？为什么会这样输出？
上面输出结果中每行日志记录的各个字段含义分别是：
日志级别:日志器名称:日志内容
之所以会这样输出，是因为logging模块提供的日志记录函数所使用的日志器设置的日志格式默认是BASIC_FORMAT，其
值为：

"%(levelname)s:%(name)s:%(message)s"
问题3：如果将日志记录输出到文件中，而不是打印到控制台？
因为在logging模块提供的日志记录函数所使用的日志器设置的处理器所指定的日志输出位置默认为:
sys.stderr
问题4：我是怎么知道这些的？
查看这些日志记录函数的实现代码，可以发现：当我们没有提供任何配置信息的时候，这些函数都会去调用
logging.basicConfig(** kwargs)方法，且不会向该方法传递任何参数。继续查看basicConfig()方法的代码就可以找到上
面这些问题的答案了。
问题5：怎么修改这些默认设置呢？
其实很简单，在我们调用上面这些日志记录函数之前，手动调用一下basicConfig()方法，把我们想设置的内容以参数的
形式传递进去就可以了。

##### logging.basicConfig()函数说明
该方法用于为logging日志系统做一些基本配置，方法定义如下：
logging.basicConfig(** kwargs)

该函数可接收的关键字参数如下：
Alt text

##### logging模块定义的格式字符串字段
我们来列举一下logging模块中定义好的可以用于format格式字符串中字段有哪些：
Alt text

##### 经过配置的日志输出
先简单配置下日志器的日志级别

logging.basicConfig(level=logging.DEBUG)
logging.debug("This is a debug log.")
logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")
输出结果：
DEBUG:root:This is a debug log.
INFO:root:This is a info log.
WARNING:root:This is a warning log.
ERROR:root:This is a error log.
CRITICAL:root:This is a critical log.
所有等级的日志信息都被输出了，说明配置生效了。
在配置日志器日志级别的基础上，在配置下日志输出目标文件和日志格式

LOG_FORMAT = "%(asctime)s ‐ %(levelname)s ‐ %(message)s"
logging.basicConfig(filename='my.log', level=logging.DEBUG, format=LOG_FORMAT)
logging.debug("This is a debug log.")
logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")
此时会发现控制台中已经没有输出日志内容了，但是在python代码文件的相同目录下会生成一个名为’my.log’的日志文
件，该文件中的内容为：
2017‐05‐08
2017‐05‐08
2017‐05‐08
2017‐05‐08
2017‐05‐08

14:29:53,783
14:29:53,784
14:29:53,784
14:29:53,784
14:29:53,784

‐
‐
‐
‐
‐

DEBUG ‐ This is a debug log.
INFO ‐ This is a info log.
WARNING ‐ This is a warning log.
ERROR ‐ This is a error log.
CRITICAL ‐ This is a critical log.

在上面的基础上，我们再来设置下日期/时间格式

LOG_FORMAT = "%(asctime)s ‐ %(levelname)s ‐ %(message)s"
DATE_FORMAT = "%m/%d/%Y %H:%M:%S %p"
logging.basicConfig(filename='my.log', level=logging.DEBUG, format=LOG_FORMAT,
datefmt=DATE_FORMAT)
logging.debug("This is a debug log.")
logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")

6. 其他说明
几个要说明的内容：
•logging.basicConfig()函数是一个一次性的简单配置工具使，也就是说只有在第一次调用该函数时会起作用，后续再次
调用该函数时完全不会产生任何操作的，多次调用的设置并不是累加操作。
•日志器（Logger）是有层级关系的，上面调用的logging模块级别的函数所使用的日志器是RootLogger类的实例，其
名称为’root’，它是处于日志器层级关系最顶层的日志器，且该实例是以单例模式存在的。
•如果要记录的日志中包含变量数据，可使用一个格式字符串作为这个事件的描述消息（logging.debug、logging.info
等函数的第一个参数），然后将变量数据作为第二个参数*args的值进行传递，如:logging.warning(‘%s is %d years
old.’, ‘Tom’, 10)，输出内容为WARNING:root:Tom is 10 years old.
•logging.debug(), logging.info()等方法的定义中，除了msg和args参数外，还有一个** kwargs参数。它们支持3个关
键字参数: exc_info, stack_info, extra，下面对这几个关键字参数作个说明。
关于exc_info, stack_info, extra关键词参数的说明:
•exc_info： 其值为布尔值，如果该参数的值设置为True，则会将异常异常信息添加到日志消息中。如果没有异常信息
则添加None到日志信息中。
•stack_info： 其值也为布尔值，默认值为False。如果该参数的值设置为True，栈信息将会被添加到日志信息中。
•extra： 这是一个字典（dict）参数，它可以用来自定义消息格式中所包含的字段，但是它的key不能与logging模块定
义的字段冲突。
一个例子：
在日志消息中添加exc_info和stack_info信息，并添加两个自定义的字端 ip和user
LOG_FORMAT = "%(asctime)s ‐ %(levelname)s ‐ %(user)s[%(ip)s] ‐ %(message)s"
DATE_FORMAT = "%m/%d/%Y %H:%M:%S %p"
logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT)
logging.warning("Some one delete the log file.", exc_info=True, stack_info=True, extra=
{'user': 'Tom', 'ip':'47.98.53.222'})
输出结果：
05/08/2017 16:35:00 PM ‐ WARNING ‐ Tom[47.98.53.222] ‐ Some one delete the log file.
NoneType
Stack (most recent call last):
File "C:/Users/wader/PycharmProjects/LearnPython/day06/log.py", line 45, in <module>
logging.warning("Some one delete the log file.", exc_info=True, stack_info=True, extra=
{'user': 'Tom', 'ip':'47.98.53.222'})

#### logging模块日志流处理流程
在介绍logging模块的高级用法之前，很有必要对logging模块所包含的重要组件以及其工作流程做个全面、简要的介
绍，这有助于我们更好的理解我们所写的代码（将会触发什么样的操作）。

##### logging日志模块四大组件
在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：
Alt text
logging模块就是通过这些组件来完成日志处理的，上面所使用的logging模块级别的函数也是通过这些组件对应的类来
实现的。
这些组件之间的关系描述：
•日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；
•不同的处理器（handler）可以将日志输出到不同的位置；
•日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；
•每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；
•每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。
简单点说就是：日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器
（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。

#####  logging日志模块相关类及其常用方法介绍
下面介绍下与logging四大组件相关的类：Logger, Handler, Filter, Formatter。
Logger类
Logger对象有3个任务要做：
•1）向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；
•2）基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；
•3）将日志消息传送给所有感兴趣的日志handlers。
Logger对象最常用的方法分为两类：配置方法 和 消息发送方法
最常用的配置方法如下：
Alt text
关于Logger.setLevel()方法的说明：
内建等级中，级别最低的是DEBUG，级别最高的是CRITICAL。例如setLevel(logging.INFO)，此时函数参数为INFO，那
么该logger将只会处理INFO、WARNING、ERROR和CRITICAL级别的日志，而DEBUG级别的消息将会被忽略/丢弃。
logger对象配置完成后，可以使用下面的方法来创建日志记录：
Alt text
那么，怎样得到一个Logger对象呢？一种方式是通过Logger类的实例化方法创建一个Logger类的实例，但是我们通常都
是用第二种方式–logging.getLogger()方法。
logging.getLogger()方法有一个可选参数name，该参数表示将要返回的日志器的名称标识，如果不提供该参数，则其
值为’root’。若以相同的name参数值多次调用getLogger()方法，将会返回指向同一个logger对象的引用。
关于logger的层级结构与有效等级的说明：
•logger的名称是一个以’.’分割的层级结构，每个’.’后面的logger都是’.’前面的logger的children，例如，有一个名称为

foo 的logger，其它名称分别为 foo.bar, foo.bar.baz 和 foo.bam都是 foo 的后代。
•logger有一个”有效等级（effective level）”的概念。如果一个logger上没有被明确设置一个level，那么该logger就是
使用它parent的level;如果它的parent也没有明确设置level则继续向上查找parent的parent的有效level，依次类推，直
到找到个一个明确设置了level的祖先为止。需要说明的是，root logger总是会有一个明确的level设置（默认为
WARNING）。当决定是否去处理一个已发生的事件时，logger的有效等级将会被用来决定是否将该事件传递给该logger
的handlers进行处理。
•child loggers在完成对日志消息的处理后，默认会将日志消息传递给与它们的祖先loggers相关的handlers。因此，我
们不必为一个应用程序中所使用的所有loggers定义和配置handlers，只需要为一个顶层的logger配置handlers，然后按
照需要创建child loggers就可足够了。我们也可以通过将一个logger的propagate属性设置为False来关闭这种传递机
制。
Handler类
Handler对象的作用是（基于日志消息的level）将消息分发到handler指定的位置（文件、网络、邮件等）。Logger对象
可以通过addHandler()方法为自己添加0个或者更多个handler对象。比如，一个应用程序可能想要实现以下几个日志需
求：
•1）把所有日志都发送到一个日志文件中；
•2）把所有严重级别大于等于error的日志发送到stdout（标准输出）；
•3）把所有严重级别为critical的日志发送到一个email邮件地址。
这种场景就需要3个不同的handlers，每个handler复杂发送一个特定严重级别的日志到一个特定的位置。
一个handler中只有非常少数的方法是需要应用开发人员去关心的。对于使用内建handler对象的应用开发人员来说，似
乎唯一相关的handler方法就是下面这几个配置方法：
Alt text
需要说明的是，应用程序代码不应该直接实例化和使用Handler实例。因为Handler是一个基类，它只定义了素有
handlers都应该有的接口，同时提供了一些子类可以直接使用或覆盖的默认行为。下面是一些常用的Handler：
Alt text
Formater类
Formater对象用于配置日志信息的最终顺序、结构和内容。与logging.Handler基类不同的是，应用代码可以直接实例
化Formatter类。另外，如果你的应用程序需要一些特殊的处理行为，也可以实现一个Formatter的子类来完成。
Formatter类的构造方法定义如下：
logging.Formatter.__init__(fmt=None, datefmt=None, style='%')
可见，该构造方法接收3个可选参数：
•fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值
•datefmt：指定日期格式字符串，如果不指定该参数则默认使用”%Y-%m-%d %H:%M:%S”
•style：Python 3.2新增的参数，可取值为 ‘%’, ‘{‘和 ‘$’，如果不指定该参数则默认使用’%’
Filter类
Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个
logger层级下的日志事件通过过滤。该类定义如下：
class logging.Filter(name='')
filter(record)
比如，一个filter实例化时传递的name参数值为’A.B’，那么该filter实例将只允许名称为类似如下规则的loggers产生的日
志记录通过过滤：’A.B’，’A.B,C’，’A.B.C.D’，’A.B.D’，而名称为’A.BB’, ‘B.A.B’的loggers产生的日志则会被过滤掉。

如果name的值为空字符串，则允许所有的日志事件通过过滤。
filter方法用于具体控制传递的record记录是否能通过过滤，如果该方法返回值为0表示不能通过过滤，返回值为非0表示
可以通过过滤。
说明：
•如果有需要，也可以在filter(record)方法内部改变该record，比如添加、删除或修改一些属性。
•我们还可以通过filter做一些统计工作，比如可以计算下被一个特殊的logger或handler所处理的record数量等。

##### logging日志流处理流程
Alt text
我们来描述下上面这个图的日志流处理流程：
•1）（在用户代码中进行）日志记录函数调用，如：logger.info(…)，logger.debug(…)等；
•2）判断要记录的日志级别是否满足日志器设置的级别要求（要记录的日志级别要大于或等于日志器设置的级别才算满
足要求），如果不满足则该日志记录会被丢弃并终止后续的操作，如果满足则继续下一步操作；
•3）根据日志记录函数调用时掺入的参数，创建一个日志记录（LogRecord类）对象；
•4）判断日志记录器上设置的过滤器是否拒绝这条日志记录，如果日志记录器上的某个过滤器拒绝，则该日志记录会被
丢弃并终止后续的操作，如果日志记录器上设置的过滤器不拒绝这条日志记录或者日志记录器上没有设置过滤器则继续下
一步操作–将日志记录分别交给该日志器上添加的各个处理器；
•5）判断要记录的日志级别是否满足处理器设置的级别要求（要记录的日志级别要大于或等于该处理器设置的日志级别
才算满足要求），如果不满足记录将会被该处理器丢弃并终止后续的操作，如果满足则继续下一步操作；
•6）判断该处理器上设置的过滤器是否拒绝这条日志记录，如果该处理器上的某个过滤器拒绝，则该日志记录会被当前
处理器丢弃并终止后续的操作，如果当前处理器上设置的过滤器不拒绝这条日志记录或当前处理器上没有设置过滤器测继
续下一步操作；
•7）如果能到这一步，说明这条日志记录经过了层层关卡允许被输出了，此时当前处理器会根据自身被设置的格式器
（如果没有设置则使用默认格式）将这条日志记录进行格式化，最后将格式化后的结果输出到指定位置（文件、网络、类
文件的Stream等）；
•8）如果日志器被设置了多个处理器的话，上面的第5-8步会执行多次；
•9）这里才是完整流程的最后一步：判断该日志器输出的日志消息是否需要传递给上一级logger（之前提到过，日志器
是有层级关系的）的处理器，如果propagate属性值为1则表示日志消息将会被输出到处理器指定的位置，同时还会被传
递给parent日志器的handlers进行处理直到当前日志器的propagate属性为0停止，如果propagate值为0则表示不向
parent日志器的handlers传递该消息，到此结束。
可见，一条日志信息要想被最终输出需要依次经过以下几次过滤：
•日志器等级过滤；
•日志器的过滤器过滤；
•日志器的处理器等级过滤；
•日志器的处理器的过滤器过滤；
需要说明的是： 关于上面第9个步骤，如果propagate值为1，那么日志消息会直接传递交给上一级logger的handlers进
行处理，此时上一级logger的日志等级并不会对该日志消息进行等级过滤。

#### 使用logging四大组件记录日志
现在，我们对logging模块的重要组件及整个日志流处理流程都应该有了一个比较全面的了解，下面我们来看一个例子。

##### 需求
现在有以下几个日志记录的需求：
•1）要求将所有级别的所有日志都写入磁盘文件中

•2）all.log文件中记录所有的日志信息，日志格式为：日期和时间 - 日志级别 - 日志信息
•3）error.log文件中单独记录error及以上级别的日志信息，日志格式为：日期和时间 - 日志级别 - 文件名[:行号] - 日
志信息
•4）要求all.log在每天凌晨进行日志切割

##### 分析
•1）要记录所有级别的日志，因此日志器的有效level需要设置为最低级别–DEBUG;
•2）日志需要被发送到两个不同的目的地，因此需要为日志器设置两个handler；另外，两个目的地都是磁盘文件，因此
这两个handler都是与FileHandler相关的；
•3）all.log要求按照时间进行日志切割，因此他需要用logging.handlers.TimedRotatingFileHandler; 而error.log没
有要求日志切割，因此可以使用FileHandler;
•4）两个日志文件的格式不同，因此需要对这两个handler分别设置格式器；

##### 代码实现
import logging
import logging.handlers
import datetime
logger = logging.getLogger('mylogger')
logger.setLevel(logging.DEBUG)
rf_handler = logging.handlers.TimedRotatingFileHandler('all.log', when='midnight',
interval=1, backupCount=7, atTime=datetime.time(0, 0, 0, 0))
rf_handler.setFormatter(logging.Formatter("%(asctime)s ‐ %(levelname)s ‐ %(message)s"))
f_handler = logging.FileHandler('error.log')
f_handler.setLevel(logging.ERROR)
f_handler.setFormatter(logging.Formatter("%(asctime)s ‐ %(levelname)s ‐ %(filename)s[:%
(lineno)d] ‐ %(message)s"))
logger.addHandler(rf_handler)
logger.addHandler(f_handler)
logger.debug('debug message')
logger.info('info message')
logger.warning('warning message')
logger.error('error message')
logger.critical('critical message')
all.log文件输出
2017‐05‐13
2017‐05‐13
2017‐05‐13
2017‐05‐13
2017‐05‐13

16:12:40,612
16:12:40,612
16:12:40,612
16:12:40,612
16:12:40,613

DEBUG ‐ debug message
INFO ‐ info message
WARNING ‐ warning message
ERROR ‐ error message
CRITICAL ‐ critical message

error.log文件输出
2017‐05‐13 16:12:40,612 ‐ ERROR ‐ log.py[:81] ‐ error message
2017‐05‐13 16:12:40,613 ‐ CRITICAL ‐ log.py[:82] ‐ critical message

## python自动化打开音乐下载网站下载音乐脚本例子

使用的是python中色selenium包，selenium2.0接入了webdriver的api

webdriver需要先安装相应浏览器的驱动放到浏览器和python的安装位置（chrome、safari、ie、fox）


```
#coding=utf-8
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
import time

chrome_obj = webdriver.Chrome()
#chrome_obj.maximize_window()

chrometitle = chrome_obj.title
print(chrometitle)

chrome_obj.get("https://music.sounm.com/yinyue/")
chrome_obj.find_element_by_xpath('//div[@class="btn-box"]').click()
chrome_obj.find_element('id','search-wd').send_keys('不要说话')
chrome_obj.find_element_by_xpath('//input[@value="netease"]').send_keys(Keys.SPACE)
chrome_obj.find_element_by_xpath('//button[@class="search-submit"]').submit()
time.sleep(100)
chrome_obj.close()
```

其中使用两种寻找方式，find_element_by_id根据id查找，还是根据相对路径find_element_by_xpath；导入keys包，发送space按键；导入time包，停止100秒

## WSGI框架
python WSGI框架详解
1.web应用的本质
1)浏览器发送一个HTTP请求
2)服务器收到请求，生成一个HTML文档
3)服务器把HTML文档作为HTTP响应的body发个浏览器
4)浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示

2.什么是WSGI,为什么需要WSGI
上面的web应用过程，如果由我们自己来实现是复杂的，接收HTTP请求，解析HTTP请求，响应HTTP请求等。
通常这些操作都由WSGI服务器来完成，WSGI（Web Server Gateway Interface）定义了WSGI服务器执行的接口，我们只需要编写服务WSGI规范的接口，然后由WSGI服务器来执行，就可以了。

3.WSGI接口编写示例

def application(environ,satrt_response):
    start_response('200 OK',[('Content-Type','text/html')])
    return '<h1>Hello,web!</h1>'
上面的application()函数就是符合WSGI标准的一个HTTP处理函数
参数说明：
environ：包含HTTP请求信息的dict对象
satrt_response:发送HTTP响应的函数
函数说明：
start_response('200 OK', [('Content-Type', 'text/html')])
发送HTTP响应的Header，Header只能发送一次，意思是start_response函数只能执行一次
'200 OK'是HTTP响应码参数，[('Content-Type', 'text/html')]表示HTTP Header

函数的返回值return '<h1>Hello,web!</h1>'作为HTTP响应body发送给服务器。

接收HTTP请求，解析HTTP请求，发送HTTP请求等操作就交由WSGI服务器去完成，WSGI接口只负责业务逻辑。

4.python WSGI服务器
python内置了一个WSGI服务器，这个模块叫做wsgiref，不过这个模块没有考虑运行效率，只是为了开发和测试使用。

5.python编写运行WSGI web应用示例
1)编写WSGI接口

def application(environ,satrt_response):
    start_response('200 OK',[('Content-Type','text/html')])
    return '<h1>Hello,web!</h1>'
2)编写server.py，启动初始化WSGI服务器，加载application()函数

复制代码
# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print "Serving HTTP on port 8000..."
# 开始监听HTTP请求:
httpd.serve_forever()
复制代码
运行：python server.py
打开浏览器，输入http://localhost:8000/，就可以看到结果了。

----------

----------


wsgi全称Web Server Gateway Interface，是一个规范，定义web服务器如何与python应用程序进行交互。

wsgi的目的有两个：
1、让Web服务器知道如何调用Python应用程序，并且把用户的请求告诉应用程序。
2、让Python应用程序知道用户的具体请求是什么，以及如何返回结果给Web服务器。

在WSGI中定义了两个角色，Web服务器端称为server或者gateway，应用程序端称为application或者framework。

server端会先收到用户的请求，然后会根据规范的要求调用application端，如下所示：

**SERVER/GATEWAY----------------APPLICATION/FRAMEWORK**

调用的结果会被封装成HTTP响应后再发送给客户端。

#server如何调用application
首先，每个application的入口只有一个，也就是所有的客户端请求都同一个入口进入到应用程序。


> 这个application就是root


接下来，server端需要知道去哪里找application的入口。这个需要在server端指定一个Python模块，也就是Python应用中的一个文件，并且这个模块中需要包含一个名称为application的可调用对象（函数和类都可以），这个application对象就是这个应用程序的唯一入口了。WSGI还定义了application对象的形式：

```
def simple_app(environ, start_response):
      pass
```
所有支持WSGI的python框架都有一个application的对象。框架的使用者不需要关心application是怎么工作的，只需要关心路由定义、请求处理等具体的业务逻辑。

#application对象需要做什么
当server调用application了之后，application就开始处理请求了，请求处理之后，application需要返回处理结果给server。**处理请求**和**返回结果**这两个动作都和environ、start_response参数有关。

##environ参数
environ参数是一个Python的字典，里面存放了所有和客户端相关的信息，这样application对象就能知道客户端请求的资源是什么，请求中带了什么数据等。environ字典包含了一些CGI规范要求的数据，以及WSGI规范新增的数据，还可能包含一些操作系统的环境变量以及Web服务器相关的环境变量。我们来看一些environ中常用的成员：

首先是CGI规范中要求的变量：

```
REQUEST_METHOD： 请求方法，是个字符串，'GET', 'POST'等
SCRIPT_NAME： HTTP请求的path中的用于查找到application对象的部分，比如Web服务器可以根据path的一部分来决定请求由哪个virtual host处理
PATH_INFO： HTTP请求的path中剩余的部分，也就是application要处理的部分
QUERY_STRING： HTTP请求中的查询字符串，URL中?后面的内容
CONTENT_TYPE： HTTP headers中的content-type内容
CONTENT_LENGTH： HTTP headers中的content-length内容
SERVER_NAME和SERVER_PORT： 服务器名和端口，这两个值和前面的SCRIPT_NAME, PATH_INFO拼起来可以得到完整的URL路径
SERVER_PROTOCOL： HTTP协议版本，HTTP/1.0或者HTTP/1.1
HTTP_： 和HTTP请求中的headers对应。
WSGI规范中还要求environ包含下列成员：

wsgi.version：表示WSGI版本，一个元组(1, 0)，表示版本1.0
wsgi.url_scheme：http或者https
wsgi.input：一个类文件的输入流，application可以通过这个获取HTTP request body
wsgi.errors：一个输出流，当应用程序出错时，可以将错误信息写入这里
wsgi.multithread：当application对象可能被多个线程同时调用时，这个值需要为True
wsgi.multiprocess：当application对象可能被多个进程同时调用时，这个值需要为True
wsgi.run_once：当server期望application对象在进程的生命周期内只被调用一次时，该值为True
```

上面列出的这些内容已经包括了客户端请求的所有数据，足够application对象处理客户端请求了。

## start_resposne参数
start_response是一个可调用对象，接收两个必选参数和一个可选参数：

```
status: 一个字符串，表示HTTP响应状态字符串
response_headers: 一个列表，包含有如下形式的元组：(header_name, header_value)，用来表示HTTP响应的headers
exc_info（可选）: 用于出错时，server需要返回给浏览器的信息
```

当application对象根据environ参数的内容执行完业务逻辑后，就需要返回结果给server端。我们知道HTTP的响应需要包含status，headers和body，所以在application对象将body作为返回值return之前，需要先调用start_response()，将status和headers的内容返回给server，这同时也是告诉server，application对象要开始返回body了。

#application对象的返回值

application对象的返回值用于为HTTP响应提供body，如果没有body，那么可以返回None。如果有body的化，那么需要返回一个可迭代的对象。server端通过遍历这个可迭代对象可以获得body的全部内容。

```
def simple_app(environ, start_response):
      status = '200 OK'
      response_headers = [('Content-type', 'text/plain')]
      start_response(status, response_headers)
      return ['hello, world']
```

app.py 一般包含了Pecan应用的入口，包含应用初始化代码
config.py 包含Pecan的应用配置，会被app.py使用
controllers/ 这个目录会包含所有的控制器，也就是API具体逻辑的地方
controllers/root.py 这个包含根路径对应的控制器
controllers/v1/ 这个目录对应v1版本的API的控制器。如果有多个版本的API，你一般能看到v2等目录。

# WSGI网关协议理解


**网关协议**是一个链接浏览器与服务器端的框架协议

B端发送request请求到服务器，服务器针对请求在路径文件夹内返回html文件给浏览器展示。

对于静态请求可以用nginx作为server，可以处理高并发。

对于动态请求可以用apache作为server，处理这些动态请求需要编写专门的动态application来处理数据返回给server。

**问题：**

- 需要花费大量的精力去处理server与application之间的通讯和传输。
- 如果换一个server，例如apache换成nginx，则applicaiton所写的接口全都不能用.
- 一种动态请求处理函数只针对一种情况，对于每种情况都写请求函数则存在大量的代码复用。

**解决：**

- 使用一个web app开发框架，基于网关协议标准实现。则不管server或者app怎么变换改动都遵循同一个网关标准。
- CGI网关协议标准     FastCGI     
- WSGI网关协议标准一开始是专门开发出来解决python后端同server接驳的框架，有了这个标准就不用考虑server是怎么运行的，只要application符合这个标准接口去开发，则可以移植到任何支持WSGI的server端。
- keystone就是一个python开源的基于WSGI接口标准的application



### **WSGI中间件**

WSGI中间件就是处于application和server之间的middleware。有点像nginx的正向代理/反向代理。中间件对于application是server，对于服务器是应用程序。中间件可以做一些缓存的功能，同时降低了server与app的耦合。

*<font size=2>正向代理：把nginx作为客户端去访问server，需要客户端设置代理服务器的ip、port等。</font>*

*<font size=2>反向代理：把nginx作为server端接收Browser的请求，并根据设置把请求分发到真正的服务器，对于客户端来说，nginx 就是一个server。</font>*

WSGI: web server（WSGI server） -- middleware -- WSGI application

- 建立socket，监听端口，等待request
- 解析信息，放到环境变量environ中，调用绑定的handler处理请求
- handler解析请求，将method、path放入environ中
- handler将一些服务器端信息也放入environ中
- WSGI handler调用WSGI application ，将environ和回调函数传给WSGI app
- app将response包含head/body/status等传给handler
- handler 通过socke传给客户端

所以从以上过程路我们知道application接受两个参数：**environ**和**start_response**。

### WSGI三个特征

1. 是一个可调用的对象

   WSGI的可调用对象的形式有函数、类、类的实例

   |   形式   |                             说明                             |
   | :------: | :----------------------------------------------------------: |
   |   函数   | WSGI application直接调用，函数里参数有environ、start_response这两个参数 |
   | 类的实例 | 类必须有\_\_call__函数，参数是environ、response，web server会调用\_\_call\_\_函数 |
   |    类    | 类必须有\_\_call__函数，参数是environ、response，web server会创建这个类实例，调用实例的\_\_call\_\_函数 |

2. 包含environ和start_response两个参数

   web server调用这个可调入对象时会传入两个参数

   - environ：CGI相关的环境变量、操作系统相关的环境变量（非必须）、WSGI相关的环境变量、服务器自定义的环境变量（非必须）

   - start_response：是web server传递给WSGI application的一个callable object。有点绕，从server看，WSGI application本身就是一个callable object，再给它传递一个callable object，start_response表现形式是一个函数

     start_response(status, response_header, exc_info=None) 

     status是状态码。response_header是列表，形式是（header_name, header_value）。exc_info是错误处理

3. 有一个可迭代的返回值

   example：

   ```python
   def my_app(environ start_respones):
       if(今天股票大涨):
           return your_app(environ, start_response)
       else:
           start_response("200 ok", [("Content-Type","text/heml")])
           return 'hello,stock'
   ```

   两种回复值，如果它web server收到else响应，那么它就以这个返回值响应它的client的请求；如果收到if响应，则调用Your_app继续迭代下去。

